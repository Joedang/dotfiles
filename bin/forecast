#!/usr/bin/env bash
# vim: set foldmethod=marker:
# get the NOAA forecast for a named city or the current IP address
# Joe Shields, 2020-11-29
#
# This could be a lot shorter. The majority of the functionality can be done in one pipe:
# curl -s "https://api.weather.gov/points/45,-122" \
#     | jq -r .properties.forecast \
#     | xargs curl -s \
#     | jq -r '.properties.periods | map(.name+" "+(.temperature | tostring)+.temperatureUnit+" "+.shortForecast) | .[]'
# This script mostly serves to make that process more CLI-comfy.
# system dependencies: Bash curl jq awk sed xargs printf geoip 
# geoip needs the city database (`geoip` and `geoip-database-extra` in Arch)
# There may be some coreutils dependencies I missed.
# web dependencies:
#   https://nominatim.openstreetmap.org (There's probably a way to get lat/lon from a city name using the GeoIP database...)
#   https://ifconfig.me (TODO: There must be some way to ask an ISP for your public address, to avoid this dep.)
#   https://api.weather.gov
#   https://forecast.weather.gov (only for viewing the forecast in a browser)

#### CONFIGURATION #### {{{
debug="" # leave empty to hide debug messages
errmsg() {
    if [ -n "$debug" ]; then
        echo "$@" 1>&2
    fi
}
# }}}

##### LOCATION ##### {{{
errmsg getting lat/lon
latlon_raw=$(
    if [ -z "$1" ]  # if no arguments given
    then # lookup lat/lon by IP address
        geoiplookup $(curl --silent https://ifconfig.me) \
            | awk ' /GeoIP City Edition/{
                        sub(/^GeoIP City Edition.*:/, ""); 
                        gsub(/,/, "");
                        #printf("%0.4f,%0.4f", $6, $7);
                        printf $6 " " $7;
                    } ' # the g format is important, because NOAA throws a fit about trailing zeroes
    else # lookup lat/lon by city name
        cityUrl="https://nominatim.openstreetmap.org/search?q=$@&format=json&limit=1"
        curl --silent "$cityUrl" \
            | jq -r '.[0].lat+" "+.[0].lon' #\
            #| xargs printf '%0.4f,%0.4f'
    fi
)
latlon=$(echo "$latlon_raw" | xargs printf '%0.3f,%0.3f' | sed 's/0*,/,/; s/0*$//')
lat=${latlon%,*} # strip off longitude
lon=${latlon##*,} # strip off latitude
errmsg latlon: $latlon
# }}}
##### FORECAST ##### {{{
errmsg getting forecast
forecast_resp=$( curl --silent "https://api.weather.gov/points/$latlon" ) 
locationName=$(echo "$forecast_resp" | jq -r '.properties.relativeLocation.properties | .city+", "+.state')
forecast=$(echo "$forecast_resp" \
            | jq -r .properties.forecast \
            | xargs curl --silent \
            | jq -r ".properties.periods" \
        )
errmsg forecast_resp: $forecast_resp
errmsg forecast: $forecast

errmsg prettifying
#echo "$forecast" | jq -r '.[].name+": "+(.[].temperature | tostring)+" ¬∞"+.[].temperatureUnit+" "+.[].shortForecast+"\n"' 
echo -e "\e[1;32m$locationName\e[22;39m"
echo "$forecast" \
    | jq -r 'map(.name+";"+(.isDaytime | tostring)+";"+(.temperature | tostring)+";"+.temperatureUnit+";"+.shortForecast) | .[]' \
    | awk -F ';' '
        BEGIN {
            CDAY="\033[93m"
            CNGT="\033[94;4m"
            RST="\033[0m"
        }
        {
            if ($2 == "true") {
                daytime = "true"
                daytime_emoji = "üåû"
            } else if ($2 == "false") {
                daytime = "false"
                daytime_emoji = "üåõ"
            } else {
                daytime = "error"
                daytime_emoji = "‚ùì"
            }
            if ((daytime == "false") && ($1 ~ Night))
                sub(/ Night/, "")

            sub(/^Today/,     "2day")
            sub(/^Tonight/,   "2nit")
            sub(/^Monday/,    "Mon.")
            sub(/^Tuesday/,   "Tue.")
            sub(/^Wednesday/, "Wed.")
            sub(/^Thursday/,  "Thu.")
            sub(/^Friday/,    "Fri.")
            sub(/^Saturday/,  "Sat.")
            sub(/^Sunday/,    "Sun.")

            name=$1
            temp=$3
            tempUnit=$4
            description=$5
            conditions = "";
            nemojis = 0;
            emojiwidth = 8; # number of character spaces allocated for condition emojis (assumed to use 2 spaces each)

            if ( ((tempUnit == "F") && (temp <= 32)) || ((tempUnit == "C") && (temp <= 0)) )
                freezing= 1
            else 
                freezing= 0
            temp= sprintf("%3.0f", $3)
            if (freezing)
                temp= "\033[48;5;18m" temp "\033[49m"
        }

        /Fog/ { conditions = "üåÅ" conditions; nemojis++ }
        /Mist/ { conditions = "üå´" conditions }
        /Snow/ { conditions = "‚ùÑ" conditions }
        /Ice/ { conditions = "üßä" conditions; nemojis++ }
        /Cloud/ { conditions = "‚òÅ" conditions }
        /Sun[^d]/ { conditions = "üåû" conditions; nemojis++ } # avoid matching "Sunday"
        #/Clear/ { conditions = "üíé" conditions; nemojis++ }
        /Wind/ { conditions = "üí®" conditions; nemojis++ }
        /Shower/ { conditions = "üöø" conditions; nemojis++ }
        /Rain/ { conditions = "üí¶" conditions; nemojis++ }
        /Warning/ { conditions = "‚ùó" conditions; nemojis++ }
        /Alert/ { conditions = "‚ùó" conditions; nemojis++ }
        /Advisory/ { conditions = "‚ùó" conditions; nemojis++ }
        {
            if (daytime == "true")
                printf CDAY
            else if (daytime == "false")
                printf CNGT
            printf("%-4s ", name); # name of the day
            printf daytime_emoji " "
            printf("%s¬∞%s ", temp, tempUnit); 
            printf("%-"(emojiwidth - nemojis)"s ", conditions); 
            printf description RST "\n"
        }'
# }}}
##### ALERTS ##### {{{
errmsg getting alerts
alerts=$(\
    curl --silent "https://api.weather.gov/alerts/active?point=$latlon&status=actual" \
        | jq -r '.features[].properties | .event+":\n\t"+.parameters.NWSheadline[]'\
    )
if [ -n "$alerts" ]; then
    echo -e "\e[1;31m$alerts\e[22;39m"
fi
# }}}
echo -e "full in-browser report: https://forecast.weather.gov/MapClick.php?lat=$lat&lon=$lon"
exit 0
